# MySQL


## 事务

### 简介

**事务** 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作**要么同时成功，要么同时失败**。

![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-16_20-17-45.png)

默认MySQL的事务是自动提交的，也就是说，当执行一条DML(增删改)语句，MySQL会立即隐式的提交事务，这意味着如果有一条DML语句执行失败，整个事务会被回滚。


查看/设置事务提交方式
```sql
-- 1自动提交 0手动提交
select @@autocommit;

SET @@autocommit = 0;

-- 提交事务
COMMIT;

-- 回滚事务
ROLLBACK;
```

开启事务
```sql
START TRANSACTION;

BEGIN;
```

### 四大特性


- 原子性(Atomicity): 事务是不可分割的最小操作单元，要么全部成功，要么全部失败。
- 一致性(Consistency): 事务完成时，数据库从一个一致的状态转变为另一个一致的状态。这意味着事务 在执行前后，不能破坏数据库数据的完整性和一致性，必须使所有的数据都保持一致状态。
- 隔离性(solation): 数据库系统提供的隔离机制，多个事务可以同时在数据库中执行，但它们之间应该是相互隔离的，一个事务的执行 不应该影响其他事务的执行，保证事务在不受外部并发操作影响的 独立环境下运行
- 持久性(Durability): 事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。即使系统发生故障或重启，也应该能够保持数据的持久性。

### 并发事务问题

- 脏读（Dirty Read）： 脏读发生在一个事务读取了另一个事务尚未提交的数据。如果这个事务最终回滚，读取到的数据就是无效的。

解决方法： 设置事务隔离级别，使用更高的隔离级别，如 READ COMMITTED， REPEATABLE READ，SERIALIZABLE 可以避免脏读。

- 不可重复读（Non-Repeatable Read）： 不可重复读发生在一个事务内，先后读取同一条记录，但两个相同查询读取的数据不同，因为在两次查询之间，另一个事务修改了数据。

解决方法： 设置隔离级别，如：REPEATABLE READ， Serializable，或者使用锁定机制。

- 幻读（Phantom Read）： 幻读 发生在一个事务内的两个相同条件查询返回了不同的结果，因为在两次查询之间，另一个事务插入或删除了数据，导致结果集发生变化，好像出现了‘幻影’。一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在。

解决方法： 设置隔离级别Serializable，通过强制事务串行化执行来避免幻读，或者使用锁定机制。

- 丢失更新（Lost Update）： 丢失更新发生在两个事务同时尝试更新相同数据，但只有一个更新生效，导致另一个更新的结果丢失。

解决方法： 使用锁定机制，如悲观锁或乐观锁，确保同时只有一个事务可以更新数据。


### 事务隔离级别

| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
| --------- | ---- | ---------- | ---- |
| READ-UNCOMMITTED | √| √| √ |
| READ-COMMITTED | × |√ |√ |
| REPEATABLE-READ | ×| × | √ |
| SERIALIZABLE  |× |× |× |


事务隔离级别越严格，数据越安全，但数据库效率越低。 MySQL 默认的事务隔离级别是：`REPEATABLE-READ`可重复读级别，简称 `RR` 级别，会出现幻读问题。

```sql
-- 查看事务隔离级别
SELECT @@TRANSACTION_ISOLATION;

-- 设置事务隔离级别
SET [SESSION|GLOBAL] TRANSACTION ISOLATION LEVEL [READ-UNCOMMITTED|READ-COMMITTED|REPEATABLE-READ|SERIALIZABLE];
```

`READ UNCOMMITTED（读未提交）`： 允许一个事务读取另一个事务未提交的数据。这是最低的隔离级别，不提供任何隔离保护。 可能出现脏读、不可重复读和幻读的问题。

`READ COMMITTED（读已提交）`： 允许一个事务只能读取其他事务已经提交的数据，看不到其他未提交事务的修改。 可能出现不可重复读和幻读的问题，但解决了脏读的问题。

`REPEATABLE READ（可重复读）`： 保证一个事务在其生命周期内多次读取相同的数据，将返回相同的结果，即使其他事务已经修改了数据。其他事务的插入操作将被阻止。 可能出现幻读的问题，但解决了脏读和不可重复读的问题。

`SERIALIZABLE（串行化）`： 提供最高的隔离级别，确保事务之间完全隔离。事务按顺序执行，所有事务都像是按照顺序串行执行的，没有并发。避免了脏读、不可重复读和幻读的问题，但会降低并发性能。 虽然能保证数据的一致性，但可能会导致大量的事务等待，降低了系统的吞吐量和性能。



## 存储引擎


### MySQL体系结构
![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-16_23-23-25.png)

- 连接层
最上层是一些客户端和链接服务，主要完成一些类似于连接处理、授权认证、及相关的安全方案。服务器也会为安全接入的每个客户端验证它所具有的操作权限。

- 服务层
第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。

- 引擎层
存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。存储引擎层负责管理数据存储、**索引**实现和管理、并发控制和事务处理。它与底层文件系统交互，以高效地读取和写入数据。

- 存储层
主要是将数据存储在文件系统之上，并完成与存储引擎的交互。



**存储引擎简介**

存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。

`mysql5.5`版本之后，默认的存储引擎为 `InnoDB`，之前的版本默认的存储引擎为 `MyISAM`。

查看当前数据库支持的存储引擎


```sql
SHOW ENGINES;
```


### InnoDB

InnoDB 是 MySQL 5.5 版本之后默认的存储引擎，它支持事务处理、行级锁定和外键完整性。InnoDB 是一个高性能的存储引擎，它在性能和并发方面都有很大的优势。



特点:
- DML操作遵循ACID模型，支持**事务**;
- **行级锁**，提高并发访问性能;
- 支持**外键 FOREIGN KEY**约束，保证数据的完整性和正确性;


文件：

`xxx.ibd`:xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构(frm、mysql8之后sdi)、数据和索引;

参数:innodb_file_per_table



:::info
mysql8.0默认使用的是innodb_file_per_table=ON，表示每个表对应一个表空间文件，而mysql5.7默认使用的是innodb_file_per_table=OFF，表示所有表共用一个表空间文件。
:::


查看表空间文件
```sql
ibd2sdi account

-- 在该ibd文件目录下cmd，命令： idb2sdi 表名
```

InnoDB逻辑存储结构
![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-16_23-58-20.png)

- 区(Extent)：一个区大小是固定的，为1M，一个区可以包含64个页。
- 页(Page)：InnoDB存储引擎将数据存储在页中，大小也是固定的，页的大小为16KB，即65536字节。页里面即使row数据。


### MyISAM

`MyISAM`是`MySQL`早期的默认存储引擎。

**特点**
- 不支持事务，不支持外键
- 支持表锁，不支持行锁
- 访问速度快

在磁盘中所涉及到的文件有`xxxx.MYD`,`xxxx.MYI`和`xxxx.SDI`三个文件。

`xxxx.MYD`表中存放的数据，`xxxx.MYI`文件存储表的索引信息，`xxxx.SDI`表结构信息。


### Memory

`Memory`引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存使用

**特点**
- 内存存放
- hash索引(默认)

**文件**

`xxx.sdi`:存储表结构信息


**区别**
![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-17_21-02-07.png)


### 存储引擎选择

在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。

- `InnoDB`:是Mysql的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。
- `MyISAM`:如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。
- `MEMORY`:将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。


## 索引的数据结构

### 为什么使用索引

索引是存储引擎用于快速找到数据记录的一种数据结构，就好比一本教科书的目录部分，通过目录中找到对应文章的页码，便可快速定位到需要的文章。MySQL中也是一样的道理，进行数据查找时，首先查看查询条件是否命中某条索引，符合则`通过索引查找`相关数据，如果不符合则需要`全表扫描`，即需要一条一条地查找记录，直到找到与条件符合的记录。

![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/wechat_2025-07-17_215138_204.png)

如上图所示，数据库没有索引的情况下，数据`分布在硬盘不同的位置上面`，读取数据时，摆臂需要前后摆动查询数据，这样操作非常消耗时间。如果`数据顺序摆放`，那么也需要从1到6行按顺序读取，这样就相当于进行了6次IO操作，`依旧非常耗时`。如果我们不借助任何索引结构帮助我们快速定位数据的话，我们查找 Col 2 = 89 这条记录，就要逐行去查找、去比较。从Col 2 = 34 开始，进行比较，发现不是，继续下一行。我们当前的表只有不到10行数据，但如果表很大的话，有上千万条数据，就意味着要做`很多很多次硬盘I/0`才能找到。现在要查找 Col 2 = 89 这条记录。CPU必须先去磁盘查找这条记录，找到之后加载到内存，再对数据进行处理。这个过程最耗时间就是磁盘I/O（涉及到磁盘的旋转时间（速度较快），磁头的寻道时间(速度慢、费时)）

假如给数据使用 `二叉树` 这样的数据结构进行存储，如下图所示

![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-17_21-52-44.png)

对字段 Col 2 添加了索引，就相当于在硬盘上为 Col 2 维护了一个索引的数据结构，即这个 `二叉搜索树`。二叉搜索树的每个结点存储的是 `(K, V) 结构`，key 是 Col 2，value 是该 key 所在行的文件指针（地址）。比如：该二叉搜索树的根节点就是：`(34, 0x07)`。现在对 Col 2 添加了索引，这时再去查找 Col 2 = 89 这条记录的时候会先去查找该二叉搜索树（二叉树的遍历查找）。读 34 到内存，89 > 34; 继续右侧数据，读 89 到内存，89==89；找到数据返回。找到之后就根据当前结点的 value 快速定位到要查找的记录对应的地址。我们可以发现，只需要 `查找两次` 就可以定位到记录的地址，查询速度就提高了。

这就是我们为什么要建索引，目的就是为了 `减少磁盘I/O的次数`，加快查询速率。


### 索引及其优缺点


**索引概述**

MySQL官方对索引的定义为：**索引（Index）是帮助MySQL高效获取数据的数据结构**。

**索引的本质**：索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。 这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现 `高级查找算法` 。

`索引是在存储引擎中实现的`，因此每种存储引擎的索引不一定完全相同，并且每种存储引擎不一定支持所有索引类型。同时，存储引擎可以定义每个表的 `最大索引数` 和 `最大索引长度`。所有存储引擎支持每个表至少16个索引，总索引长度至少为256字节。有些存储引擎支持更多的索引数和更大的索引长度。

#### 优点
（1）类似大学图书馆建书目索引，提高数据检索的效率，**降低数据库的IO成本** ，这也是创建索引最主 要的原因。

（2）通过创建唯一索引，可以保证数据库表中每一行**数据的唯一性** 。

（3）在实现数据的 参考完整性方面，可以**加速表和表之间的连接** 。换句话说，对于有依赖关系的子表和父表联合查询时， 可以提高查询速度。

（4）在使用分组和排序子句进行数据查询时，可以显著**减少查询中分组和排序的时间** ，降低了CPU的消耗。

#### 缺点
增加索引也有许多不利的方面，主要表现在如下几个方面：

（1）创建索引和维护索引要 **耗费时间** ，并 且随着数据量的增加，所耗费的时间也会增加。

（2）索引需要占 **磁盘空间** ，除了数据表占数据空间之 外，每一个索引还要占一定的物理空间， 存储在磁盘上 ，如果有大量的索引，索引文件就可能比数据文 件更快达到最大文件尺寸。

（3）虽然索引大大提高了查询速度，同时却会 **降低更新表的速度** 。当对表 中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。 因此，选择使用索引时，需要综合考虑索引的优点和缺点。

因此，选择使用索引时，需要综合考虑索引的优点和缺点。

:::tip
提示：

索引可以提高查询的速度，但是会影响插入记录的速度。这种情况下，最好的办法是先删除表中的索引，然后插入数据，插入完成后再创建索引。
:::


## InnoDB中索引的推演

### 索引之前的查找

先来看一个精确匹配的例子：

```sql
SELECT [列名列表] FROM 表名 WHERE 列名 = xxx;
```

**1. 在一个页中的查找**

假设目前表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况：

- 以主键为搜索条件

    可以在页目录中使用 **二分法** 快速定位到对应的槽，然后再遍历该槽对用分组中的记录即可快速找到指定记录。

- 以其他列作为搜索条件
    
    因为在数据页中并没有对非主键列简历所谓的页目录，所以我们无法通过二分法快速定位相应的槽。这种情况下只能从 **最小记录** 开始 **依次遍历单链表中的每条记录**， 然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。

2. 在很多页中查找
在很多页中查找记录的活动可以分为两个步骤：

    1. 定位到记录所在的页。
    2. 从所在的页内中查找相应的记录。



在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能 `从第一个页`沿着`双向链表` 一直往下找，在每一个页中根据我们上面的查找方式去查 找指定的记录。因为要遍历所有的数据页，所以这种方式显然是 `超级耗时` 的。如果一个表有一亿条记录呢？此时 `索引` 应运而生。

### 设计索引

建一个表：
```sql
mysql> CREATE TABLE index_demo(
-> c1 INT,
-> c2 INT,
-> c3 CHAR(1),
-> PRIMARY KEY(c1)
-> ) ROW_FORMAT = Compact;
```
这个新建的 `index_demo` 表中有2个INT类型的列，1个CHAR(1)类型的列，而且我们规定了c1列为主键， 这个表使用 `Compact` 行格式来实际存储记录的。这里我们简化了index_demo表的行格式示意图：
![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-17_22-45-21.png)

我们只在示意图里展示记录的这几个部分：

- `record_type` ：记录头信息的一项属性，表示记录的类型， `0` 表示普通记录、 `2` 表示最小记录、 `3` 表示最大记录、 `1` 暂时还没用过，下面讲。
- `next_record` ：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用 箭头来表明下一条记录是谁。
- `各个列的值` ：这里只记录在 `index_demo` 表中的三个列，分别是 `c1` 、 `c2` 和 `c3` 。
- `其他信息` ：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。

将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果就是这样：
![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-17_22-47-33.png)

把一些记录放到页里的示意图就是：

![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-17_22-48-06.png)


#### 一个简单的索引设计方案


我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。所以如果我们 `想快速的定位到需要查找的记录在哪些数据页` 中该咋办？我们可以为快速定位记录所在的数据页而`建立一个目录` ，建这个目录必须完成下边这些事：

- **下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。**
- **给所有的页建立一个目录项。**

假设：每个数据结构最多能存放3条记录（实际上一个数据页非常大，可以存放下好多记录）。
```sql
INSERT INTO index_demo VALUES(1, 4, 'u'), (3, 9, 'd'), (5, 3, 'y');
```

那么这些记录以及按照主键值的大小串联成一个单向链表了，如图所示：
![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-17_22-53-46.png)

从图中可以看出来， `index_demo` 表中的3条记录都被插入到了编号为10的数据页中了。此时我们再来插入一条记录
```sql
INSERT INTO index_demo VALUES(4, 4, 'a');
```
因为 **页10** 最多只能放3条记录，所以我们不得不再分配一个新页：这个过程称为 `页分裂`。

![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-17_22-55-07.png)

注意：新分配的 **数据页编号可能并不是连续的**。它们只是通过维护者上一个页和下一个页的编号而建立了 `链表` 关系。另外，**页10**中用户记录最大的主键值是5，而页28中有一条记录的主键值是4，因为5>4，所以这就不符合下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值的要求，所以在插入主键值为4的记录的时候需要伴随着一次 `记录移动`，也就是把主键值为5的记录移动到页28中，然后再把主键值为4的记录插入到页10中，这个过程的示意图如下：

![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-17_22-57-30.png)

这个过程表明了在对页中的记录进行增删改查操作的过程中，我们必须通过一些诸如 `记录移动` 的操作来始终保证这个状态一直成立：下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。

- **给所有的页建立一个目录项。**

由于数据页的 **编号可能是不连续** 的，所以在向 index_demo 表中插入许多条记录后，可能是这样的效果：
![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-17_22-59-17.png)

我们需要给它们做个 目录，每个页对应一个目录项，每个目录项包括下边两个部分：

    1）页的用户记录中最小的主键值，我们用 key 来表示。

    2）页号，我们用 page_on 表示。



所以我们为上边几个页做好的目录就像这样子:
![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-17_22-51-12.png)

以 页28 为例，它对应 目录项2 ，这个目录项中包含着该页的页号 28 以及该页中用户记录的最小主 键值 5 。我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键 值快速查找某条记录的功能了。比如：查找主键值为 20 的记录，具体查找过程分两步：

1. 先从目录项中根据 二分法 快速确定出主键值为 20 的记录在 目录项3 中（因为 12 < 20 < 209 ），它对应的页是 页9 。
2. 再根据前边说的在页中查找记录的方式去 页9 中定位具体的记录。

至此，针对数据页做的简易目录就搞定了。这个目录有一个别名，称为 `索引` 。



### InnoDB中的索引方案


**① 迭代1次：目录项纪录的页**

InnoDB怎么区分一条记录是普通的 **用户记录** 还是 **目录项记录** 呢？使用记录头信息里的 `record_type` 属性，它的各自取值代表的意思如下：

- 0：普通的用户记录
- 1：目录项记录
- 2：最小记录
- 3：最大记录

我们把前边使用到的目录项放到数据页中的样子就是这样：
![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-17_23-25-01.png)


从图中可以看出来，我们新分配了一个编号为30的页来专门存储目录项记录。这里再次强调 **目录项记录** 和普通的 **用户记录** 的不同点：

- **目录项记录** 的 record_type 值是1，而 **普通用户记录** 的 record_type 值是0。
- 目录项记录只有 **主键值和页的编号** 两个列，而普通的用户记录的列是用户自己定义的，可能包含 **很多列** ，另外还有InnoDB自己添加的隐藏列。
- 了解：记录头信息里还有一个叫 min_rec_mask 的属性，只有在存储 **目录项记录** 的页中的主键值最小的 **目录项记录** 的 min_rec_mask 值为 1 ，其他别的记录的 min_rec_mask 值都是 0 。

**相同点**：两者用的是一样的数据页，都会为主键值生成 **Page Directory （页目录）**，从而在按照主键值进行查找时可以使用 `二分法` 来加快查询速度。

现在以查找主键为 20 的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：

1. 先到存储 目录项记录 的页，也就是页30中通过 二分法 快速定位到对应目录项，因为 12 < 20 < 209 ，所以定位到对应的记录所在的页就是页9。
2. 再到存储用户记录的页9中根据 二分法 快速定位到主键值为 20 的用户记录。

**② 迭代2次：多个目录项纪录的页**
![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-17_23-29-26.png)

从图中可以看出，我们插入了一条主键值为320的用户记录之后需要两个新的数据页：

- 为存储该用户记录而新生成了 `页31` 。
- 因为原先存储目录项记录的 `页30的容量已满` （我们前边假设只能存储4条目录项记录），所以不得 不需要一个新的 `页32` 来存放 `页31` 对应的目录项。

现在因为存储目录项记录的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步骤，以查找主键值为 `20` 的记录为例：

1. 确定 目录项记录页 我们现在的存储目录项记录的页有两个，即 `页30` 和 `页32` ，又因为页30表示的目录项的主键值的 范围是 `[1, 320)` ，页32表示的目录项的主键值不小于 `320` ，所以主键值为 `20` 的记录对应的目 录项记录在 `页30` 中。
2. 通过目录项记录页 `确定用户记录真实所在的页` 。 在一个存储 `目录项记录` 的页中通过主键值定位一条目录项记录的方式说过了。
3. 在真实存储用户记录的页中定位到具体的记录。


**③ 迭代3次：目录项记录页的目录页**

如果我们表中的数据非常多则会`产生很多存储目录项记录的页`，那我们怎么根据主键值快速定位一个存储目录项记录的页呢？那就为这些存储目录项记录的页再生成一个`更高级的目录`，就像是一个多级目录一样，`大目录里嵌套小目录`，小目录里才是实际的数据，所以现在各个页的示意图就是这样子：


![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-17_23-33-17.png)

如图，我们生成了一个存储更高级目录项的 `页33` ，这个页中的两条记录分别代表页30和页32，如果用 户记录的主键值在 `[1, 320)` 之间，则到页30中查找更详细的目录项记录，如果主键值 `不小于320` 的 话，就到页32中查找更详细的目录项记录。

我们可以用下边这个图来描述它：
![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-17_23-34-47.png)

这个数据结构，它的名称是 `B+树` 。

#### B+Tree

为什么b+树最多只有4层？

一个B+树的节点其实可以分成好多层，规定最下边的那层，也就是存放我们用户记录的那层为第 0 层， 之后依次往上加。之前我们做了一个非常极端的假设：存放用户记录的页 最多存放3条记录 ，存放目录项 记录的页 最多存放4条记录 。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放**用户记录** 的叶子节点代表的**数据页**可以存放 100条用户记录 ，所有存放目录项记录的内节点代表的**数据页**可以存 放 1000条目录项记录 ，那么：

- 如果B+树只有1层，也就是只有1个用于存放**用户记录**的节点，最多能存放 100 条记录。
- 如果B+树有2层，最多能存放 1000×100=10,0000  十万条记录。
- 如果B+树有3层，最多能存放 1000×1000×100=1,0000,0000 一亿条条记录。
- 如果B+树有4层，最多能存放 1000×1000×1000×100=1000,0000,0000 条记录。相当多的记录！

你的表里能存放 100000000000 条记录吗？所以一般情况下，我们用到的 `B+树都不会超过4层` ，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个`目录项页`和一个`用户记录`页），又因为在每个页面内有所谓的 Page Directory （页目录），所以在页面内也可以通过 **二分法** 实现快速 定位记录。


### 常见索引概念

索引按照物理实现方式，索引可以分为 2 种：聚簇（聚集）和非聚簇（非聚集）索引。我们也把非聚集 索引称为二级索引或者辅助索引。

#### 聚簇索引

聚簇索引并不是一种单独的索引类型，而是`一种数据存储方式`（所有的**用户记录**都存储在了叶子结点），也就是所谓的 `索引即数据，数据即索引`。

>术语"聚簇"表示当前数据行和相邻的键值聚簇的存储在一起

特点：

- 使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：
    - `页内` 的记录是按照主键的大小顺序排成一个 `单向链表` 。
    - 各个存放 `用户记录的页` 也是根据页中用户记录的主键大小顺序排成一个 `双向链表` 。
    - 存放 `目录项记录的页` 分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个 `双向链表` 。

- B+树的 `叶子节点` 存储的是完整的用户记录。

    所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。

我们把具有这两种特性的B+树称为聚簇索引，所有完整的用户记录都存放在这个`聚簇索引`的叶子节点处。这种聚簇索引并不需要我们在MySQL语句中显式的使用INDEX 语句去创建， `InnDB` 存储引擎会 `自动` 的为我们创建聚簇索引。

**优点：**

- `数据访问更快` ，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快
- 聚簇索引对于主键的 `排序查找` 和 `范围查找` 速度非常快
- 按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多 个数据块中提取数据，所以 `节省了大量的io操作` 。

**缺点：**

- `插入速度严重依赖于插入顺序` ，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键
- `更新主键的代价很高` ，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新
- `二级索引访问需要两次索引查找` ，第一次找到主键值，第二次根据主键值找到行数据


#### 二级索引（辅助索引、非聚簇索引）

如果我们想以别的列作为搜索条件该怎么办？肯定不能是从头到尾沿着链表依次遍历记录一遍。

答案：我们可以`多建几颗B+树`，不同的B+树中的数据采用不同的排列规则。比方说我们用c2列的大小作为数据页、页中记录的排序规则，再建一课B+树，效果如下图所示：
![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-18_00-26-18.png)

这个B+树与上边介绍的聚簇索引有几处不同：


- 使用记录c2列的大小进行记录和页的排序，这包括三个方面的含义:
    - 页内的记录是按照c2列的大小顺序排成一个 `单向链表`。
    - 各个存放 `用户记录的页` 也是根据页中记录的c2列大小顺序排成一个 `双向链表` 。
    - 存放 `目录项记录的页` 分为不同的层次，在同一层次中的页也是根据页中目录项记录的c2列大小顺序排成一个 `双向链表`。
- B+树的叶子节点存储的并不是完整的用户记录，而只是 `c2列+主键` 这两个列的值
- 目录项记录中不再是 `主键+页号` 的搭配，而变成了 `c2列+页号` 的搭配。


所以如果我们现在想通过c2列的值查找某些记录的话就可以使用我们刚刚建好的这个B+树了。以查找c2列的值为`4`的记录为例，查找过程如下

1. 确定 `目录项记录页`
    
    根据 `根页面`，也就是`页44`，可以快速定位到 目`录项记录`所在的页为`页42`(因为`2<4<9`)。
    
2. 通过 `目录项记录` 页确定用户记录真实所在的页

在`页42` 中可以快速定位到实际存储用户记录的页，但是由于`c2` 列并没有唯一性约束，所以 `c2` 列值为`4`的记录可能分布在多个数据页中，又因为`2<4≤4`，所以确定实际存储用户记录的页在 `页34` 和 `页35` 中。

3. 在真实存储用户记录的页中定位到具体的记录。

到 `页34` 和 `页35` 中定位到具体的记录。

4. 但是这个B+树的叶子节点中的记录只存储了 `c2`和 `c1`(也就是 `主键`)两个列，所以我们必须再根据主键值4去聚簇索引中再查找一遍完整的用户记录。

---

概念：**回表**

我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根据c2列的值查找到完整的用户记录的话，仍然需要到 `聚簇索引` 中再查一遍，这个过程称为 `回表` 。也就是根据c2列的值查询一条完整的用户记录需要使用到 `2` 棵B+树！

---

>问题：为什么我们还需要一次 `回表` 操作呢？直接把完整的用户记录放到叶子节点不OK吗？

回答：

如果把完整的用户记录放到叶子结点是可以不用回表。但是太占地方了，相当于每建立一课B+树都需要把所有的用户记录再都拷贝一遍，这就有点太浪费存储空间了。
比如表中有10个字段，意味着把每个字段都要拷贝一遍，放到叶子节点，叶子节点又完整的存储了表中所有记录。而且一张表是可以有多个聚簇索引，假如有三个聚簇索引，
每个二级索引都存储了一份完整的表记录，那表记录一共存储了四份，这就乱了，冗余特别大；

因为这种按照非主键列建立的B+树需要一次回表操作才可以定位到完整的用户记录，所以这种B+树也被称为二级索引，或者辅助索引。由于使用的是c2列的大小作为B+树的排序规则，所以我们也称这个B+树为c2列建立的索引。

---

非聚簇索引的存在不影响数据在聚簇索引中的组织，所以一张表可以有多个非聚簇索引。

![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-18_00-38-17.png)

---

小结：聚簇索引与非聚簇索引的原理不同，在使用上也有一些区别：

1. 聚簇索引的`叶子节点`存储的就是我们的`数据记录`, 非聚簇索引的叶子节点存储的是`数据位置`。非聚簇索引不会影响数据表的物理存储顺序。
2. 一个表`只能有一个聚簇索引`，因为只能有一种排序存储的方式，但可以有`多个非聚簇索引`，也就是多个索引目录提供数据检索。
3. 使用聚簇索引的时候，数据的`查询效率高`，但如果对数据进行插入，删除，更新等操作，效率会比非聚簇索引低。

