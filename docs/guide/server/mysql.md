# MySQL


## 事务

### 简介

**事务** 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作**要么同时成功，要么同时失败**。

![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-16_20-17-45.png)

默认MySQL的事务是自动提交的，也就是说，当执行一条DML(增删改)语句，MySQL会立即隐式的提交事务，这意味着如果有一条DML语句执行失败，整个事务会被回滚。


查看/设置事务提交方式
```sql
-- 1自动提交 0手动提交
select @@autocommit;

SET @@autocommit = 0;

-- 提交事务
COMMIT;

-- 回滚事务
ROLLBACK;
```

开启事务
```sql
START TRANSACTION;

BEGIN;
```

### 四大特性


- 原子性(Atomicity): 事务是不可分割的最小操作单元，要么全部成功，要么全部失败。
- 一致性(Consistency): 事务完成时，数据库从一个一致的状态转变为另一个一致的状态。这意味着事务 在执行前后，不能破坏数据库数据的完整性和一致性，必须使所有的数据都保持一致状态。
- 隔离性(solation): 数据库系统提供的隔离机制，多个事务可以同时在数据库中执行，但它们之间应该是相互隔离的，一个事务的执行 不应该影响其他事务的执行，保证事务在不受外部并发操作影响的 独立环境下运行
- 持久性(Durability): 事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。即使系统发生故障或重启，也应该能够保持数据的持久性。

### 并发事务问题

- 脏读（Dirty Read）： 脏读发生在一个事务读取了另一个事务尚未提交的数据。如果这个事务最终回滚，读取到的数据就是无效的。

解决方法： 设置事务隔离级别，使用更高的隔离级别，如 READ COMMITTED， REPEATABLE READ，SERIALIZABLE 可以避免脏读。

- 不可重复读（Non-Repeatable Read）： 不可重复读发生在一个事务内，先后读取同一条记录，但两个相同查询读取的数据不同，因为在两次查询之间，另一个事务修改了数据。

解决方法： 设置隔离级别，如：REPEATABLE READ， Serializable，或者使用锁定机制。

- 幻读（Phantom Read）： 幻读 发生在一个事务内的两个相同条件查询返回了不同的结果，因为在两次查询之间，另一个事务插入或删除了数据，导致结果集发生变化，好像出现了‘幻影’。一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在。

解决方法： 设置隔离级别Serializable，通过强制事务串行化执行来避免幻读，或者使用锁定机制。

- 丢失更新（Lost Update）： 丢失更新发生在两个事务同时尝试更新相同数据，但只有一个更新生效，导致另一个更新的结果丢失。

解决方法： 使用锁定机制，如悲观锁或乐观锁，确保同时只有一个事务可以更新数据。


### 事务隔离级别

| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
| --------- | ---- | ---------- | ---- |
| READ-UNCOMMITTED | √| √| √ |
| READ-COMMITTED | × |√ |√ |
| REPEATABLE-READ | ×| × | √ |
| SERIALIZABLE  |× |× |× |


事务隔离级别越严格，数据越安全，但数据库效率越低。 MySQL 默认的事务隔离级别是：`REPEATABLE-READ`可重复读级别，简称 `RR` 级别，会出现幻读问题。

```sql
-- 查看事务隔离级别
SELECT @@TRANSACTION_ISOLATION;

-- 设置事务隔离级别
SET [SESSION|GLOBAL] TRANSACTION ISOLATION LEVEL [READ-UNCOMMITTED|READ-COMMITTED|REPEATABLE-READ|SERIALIZABLE];
```

`READ UNCOMMITTED（读未提交）`： 允许一个事务读取另一个事务未提交的数据。这是最低的隔离级别，不提供任何隔离保护。 可能出现脏读、不可重复读和幻读的问题。

`READ COMMITTED（读已提交）`： 允许一个事务只能读取其他事务已经提交的数据，看不到其他未提交事务的修改。 可能出现不可重复读和幻读的问题，但解决了脏读的问题。

`REPEATABLE READ（可重复读）`： 保证一个事务在其生命周期内多次读取相同的数据，将返回相同的结果，即使其他事务已经修改了数据。其他事务的插入操作将被阻止。 可能出现幻读的问题，但解决了脏读和不可重复读的问题。

`SERIALIZABLE（串行化）`： 提供最高的隔离级别，确保事务之间完全隔离。事务按顺序执行，所有事务都像是按照顺序串行执行的，没有并发。避免了脏读、不可重复读和幻读的问题，但会降低并发性能。 虽然能保证数据的一致性，但可能会导致大量的事务等待，降低了系统的吞吐量和性能。



## 存储引擎


### MySQL体系结构
![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-16_23-23-25.png)

- 连接层
最上层是一些客户端和链接服务，主要完成一些类似于连接处理、授权认证、及相关的安全方案。服务器也会为安全接入的每个客户端验证它所具有的操作权限。

- 服务层
第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。

- 引擎层
存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。存储引擎层负责管理数据存储、**索引**实现和管理、并发控制和事务处理。它与底层文件系统交互，以高效地读取和写入数据。

- 存储层
主要是将数据存储在文件系统之上，并完成与存储引擎的交互。



**存储引擎简介**

存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。

`mysql5.5`版本之后，默认的存储引擎为 `InnoDB`，之前的版本默认的存储引擎为 `MyISAM`。

查看当前数据库支持的存储引擎


```sql
SHOW ENGINES;
```


### InnoDB

InnoDB 是 MySQL 5.5 版本之后默认的存储引擎，它支持事务处理、行级锁定和外键完整性。InnoDB 是一个高性能的存储引擎，它在性能和并发方面都有很大的优势。



特点:
- DML操作遵循ACID模型，支持**事务**;
- **行级锁**，提高并发访问性能;
- 支持**外键 FOREIGN KEY**约束，保证数据的完整性和正确性;


文件：

`xxx.ibd`:xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构(frm、sdi)、数据和索引;

参数:innodb_file_per_table



:::info
mysql8.0默认使用的是innodb_file_per_table=ON，表示每个表对应一个表空间文件，而mysql5.7默认使用的是innodb_file_per_table=OFF，表示所有表共用一个表空间文件。
:::


查看表空间文件
```sql
ibd2sdi account

-- 在该ibd文件目录下cmd，命令： idb2sdi 表名
```

InnoDB逻辑存储结构
![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-16_23-58-20.png)

- 区(Extent)：一个区大小是固定的，为1M，一个区可以包含64个页。
- 页(Page)：InnoDB存储引擎将数据存储在页中，大小也是固定的，页的大小为16KB，即65536字节。页里面即使row数据。
