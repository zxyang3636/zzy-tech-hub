# RabbitMQ

## 初识MQ


**同步调用**

>同步调用的优势是什么？
- 时效性强，等待到结果后才返回。

---

>同步调用的问题是什么？
- 拓展性差
- 性能下降
- 级联失败问题


---

**异步调用**

异步调用通常是基于消息通知的方式，包含三个角色：
- 消息发送者：投递消息的人，就是原来的调用者
- 消息接收者：接收和处理消息的人，就是原来的服务提供者
- 消息代理：管理、暂存、转发消息，你可以把它理解成微信服务器



支付服务不再同步调用业务关联度低的服务，而是发送消息通知到Broker。

![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-05-22_22-16-43.png)

在异步调用中，发送者不再直接同步调用接收者的业务接口，而是发送一条消息投递给消息Broker。然后接收者根据自己的需求从消息Broker那里订阅消息。每当发送方发送消息后，接受者都能获取消息并处理。

这样，发送消息的人和接收消息的人就完全解耦了。

除了扣减余额、更新支付流水单状态以外，其它调用逻辑全部取消。而是改为发送一条消息到Broker。而相关的微服务都可以订阅消息通知，一旦消息到达Broker，则会分发给每一个订阅了的微服务，处理各自的业务。

不管后期增加了多少消息订阅者，作为支付服务来讲，执行问扣减余额、更新支付流水状态后，发送消息即可。业务耗时仅仅是这三部分业务耗时，仅仅100ms，大大提高了业务性能。

另外，不管是交易服务、通知服务，还是积分服务，他们的业务与支付关联度低。现在采用了异步调用，解除了耦合，他们即便执行过程中出现了故障，也不会影响到支付服务。

异调用的优势是什么？
- 耦合度低，拓展性强
- 异步调用，无需等待，性能好
- 故障隔离，下游服务故障不影响上游业务
- 缓存消息，流量削峰填谷

异步调用的问题是什么？
- 不能立即得到调用结果，时效性差
- 不确定下游业务执行是否成功
- 业务安全依赖于Broker的可靠性


### MQ技术选型

MQ （MessageQueue），中文是消息队列，字面来看就是存放消息的队列。也就是异步调用中的Broker。


目比较常见的MQ实现：
- ActiveMQ
- RabbitMQ
- RocketMQ
- Kafka


几种常见MQ的对比：
|        |	RabbitMQ	|ActiveMQ|	RocketMQ	|Kafka
|-----------|----|-------|-----|-----|
|公司/社区	|Rabbit|	Apache|	阿里|	Apache
|开发语言	|Erlang	|Java	|Java	|Scala&Java
|协议支持	|AMQP，XMPP，SMTP，STOMP|	OpenWire,STOMP，REST,XMPP,AMQP	|自定义协议|	自定义协议
|可用性	|  高	|一般	|高  	|高
|单机吞吐量	|一般	|差	|高	|非常高
|消息延迟	|微秒级|	毫秒级|	毫秒级	|毫秒以内
|消息可靠性|	高	|一般	|高	|一般

- 追求可用性：Kafka、 RocketMQ 、RabbitMQ
- 追求可靠性：RabbitMQ、RocketMQ
- 追求吞吐能力：RocketMQ、Kafka
- 追求消息低延迟：RabbitMQ、Kafka

据统计，目前国内消息队列使用最多的还是RabbitMQ，再加上其各方面都比较均衡，稳定性也好






















